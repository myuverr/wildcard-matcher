# Wildcard Matcher

一个 C++项目，用于解决带通配符 `?` 和 `*` 的字符串匹配问题。项目内置了四种不同的算法实现，可通过宏定义进行切换。

## 问题定义

判断一个字符串 `s` (仅含小写字母) 能否被一个模式串 `p` (含小写字母、`?` 和 `*`) 完全匹配。

- `?` 匹配任意单个字符。
- `*` 匹配任意长度的字符串序列（包括空序列）。

## 算法实现

项目通过修改 `include/wildcard_matcher.h` 中的 `SOLVER_CHOICE` 宏来选择不同的实现。以下算法按照实现难度由易到难排序。

### 1. 递归与回溯 (Recursive Backtracking)

- **核心思想**
  通过递归函数进行深度优先搜索。当遇到 `*` 时，产生两个分支：`*` 匹配空串（模式串指针后移），或 `*` 匹配一个字符（字符串指针后移），并对所有可能性进行回溯。

- **复杂度分析**

  - 时间复杂度: `O(2^(m+n))` (最坏情况，无记忆化)
  - 空间复杂度: `O(m+n)` (递归栈深度)

- **优缺点**
  - **优点**: 逻辑直观，代码实现直接反映了问题的定义，易于理解。
  - **缺点**: 存在大量重叠子问题，未经优化的性能极差，在 `*` 较多的情况下会因超时而无法通过。

### 2. 动态规划 (Dynamic Programming)

- **核心思想**
  构建一个二维 `dp` 表，其中 `dp[i][j]` 表示 `s` 的前 `i` 个字符是否能与 `p` 的前 `j` 个字符匹配。通过自底向上填充该表来求解，有效避免了重叠子问题。

- **复杂度分析**

  - 时间复杂度: `O(m*n)`
  - 空间复杂度: `O(m*n)`

- **优缺点**
  - **优点**: 性能稳定高效，是此类问题的标准解决方案，一定能通过所有测试用例。
  - **缺点**: 空间复杂度较高，当字符串很长时，内存开销显著。

### 3. 基于状态机的实现 (或空间优化 DP)

- **核心思想**
  此方法可被视为对一个由模式串 `p` 构建的“非确定性有限状态机 (NFA)”的模拟。我们用一个一维数组 `dp` 来追踪在读入 `s` 的每个字符后，NFA 可能达到的所有状态的集合。在具体实现上，它等同于对二维 DP 的解法进行空间优化。

- **复杂度分析**

  - 时间复杂度: `O(m*n)`
  - 空间复杂度: `O(n)`

- **优缺点**
  - **优点**: 保持了动态规划的时间效率，同时将空间开销降至线性级别，是兼具性能和效率的优选方案。
  - **缺点**: 实现上比二维 DP 稍复杂，需要额外变量来处理状态依赖关系，可读性略微下降。

### 4. 双指针贪心法 (Two-Pointer Greedy)

- **核心思想**
  使用两个主指针 `s_ptr` 和 `p_ptr` 遍历字符串和模式串。当遇到 `*` 时，用两个辅助指针记录下 `*` 的位置和对应的 `s` 的位置。后续若发生不匹配，则回溯到记录的 `*` 位置，并让 `s` 的指针前进一位，相当于让 `*` 多匹配一个字符。

- **复杂度分析**

  - 时间复杂度: `O(m*n)` (最坏情况，但平均性能通常优于此)
  - 空间复杂度: `O(1)`

- **优缺点**
  - **优点**: 空间效率达到最优，代码执行效率在大多数情况下也非常高。
  - **缺点**: 逻辑非常不直观，指针的回溯和更新逻辑精巧但晦涩，是四种方法中最难正确实现的。
